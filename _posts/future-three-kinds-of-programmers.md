---
    layout: post
    publish: false
    title: Three Kinds of Programmers
---

Among other things, I am a programming language designer. I often have to explain _why_ I do this, “when there are so many perfectly good languages out there.” I'm surprised anyone things there is even one “perfectly good/usable/whatever” language out there. If I stop a random person on the street and ask them which programming language they most enjoy using, I'm more likely to get a blank stare than an answer.

Another question I often get is "aren't there already too many programming languages?" To which I'm never sure what to answer – how many there are doesn't matter if none of them are the right one. But yes – there are way too many languages that do the same things with slightly different syntaxes. Do I want to stop the explosion of programming languages? Not at all – I want to encourage their proliferation. I want thousands of new languages to be born. But I don't think we should be designing languages that differ in whether they use braces or indentation to indicate scope.

What we need are languages that operate at the level of the problems being solved. You already know what these things are – they are DSLs (domain-specific languages).

We need to create three kinds of programmers – language designers, language designers, and Everyone. And while there may be some sort of implicit ordering of programming skill implied, there are really trade-offs between the three levels.

The first level of language designer should be pretty rare. These are probably largely academics and researchers who understand things like compiler design, parallelism, type systems, and are always pushing to discover new things about them. These are the designers of “general purpose” languages. “General purpose” is a misnomer here (as it is for all programming languages). These are really DSLs for the purpose of creating other programming languages. This is the kind of language that is [a failure if its compiler isn't written in itself](http://en.wikipedia.org/wiki/Bootstrapping_(compilers)). If you think you wrote a better language-writing language than anyone else, the least you can do is write your own language in it. C compilers are written in C, Lisp compilers are written in Lisp, etc. Eat your own dogfood.

The next level of language designer is more common. These are the programmers that exist everywhere now (or, at least a good portion of those programmers). Except that now these programmers are creating applications rather than languages. Static, inflexible applications, designed to do only what people decided ahead of time that they needed to do. In the future they will be using the language-writing languages to write languages to be used by experts in specific fields.

These programmers also have to be good, but different than the first class. The first class has themselves and other professional programmers as users. They can converse at levels that might confuse the hell out of anyone else. The second class of language designers need to be able to both design a good language (), but also communicate with domain experts who have little-to-no formal programming training and provide language constructs that the domain experts can easily understand and use correctly. This is definitely not an easy task, and while they shouldn't need to worry about things like thread-safety (which are managed within the lower-level languages), successfully creating a language for non-professional programmers is a herculean task.

This brings us to the third class – everyone. We are so far from this class existing that it's not even funny. There are tons of DSLs loose in the world – TeX, make, etc. But almost all of them are only usable by programmers. Everyone should be able to hook up some simple sensors in their house and express an idea like "if all of the doors and windows in a room are closed, and the motion detector doesn't detect motion, then close the heating registers in that room." Or, write a "pizza" program for their oven that when run auto-sets the temperature and cooking style (broiling), adjusts the height of the oven tray, alerts the user when it's time to insert and remove the pizza, and then modifies itself when feedback is presented – crust too crispy, cheese not melted, etc.

Of course there are going to be rough edges – users aren't going to understand that when a certain value crosses from an int to a bignum that performance will drop precipitously. But despite these problems, we are still so far away from where we could be in terms of having languages that allow people to express problems in language that they can understand.

If this is done well, the answer to "which programming language do you most enjoy using?" might still be a blank stare, but it'll be because they don't think of what they're doing as programming, rather than because they've never written a program of their own.

Of course, this doesn't encapsulate everything – applications are still useful. When you want to buy a plane ticket, you don't want to write a program, you want to select some options and click buy. Rather than the application being written by programmers and UI designers, it will probably be written by domain experts and UI designers, using languages created by the programmers. UI designers are sort of another level of language designer. They develop a (usually graphical) language to be used by non-programming non-domain experts.

Additionally, the DSL creators are also creating libraries to add generic functionality, like XML parsing, data persistence, serialization, etc. that can be shared with other DSL creators. And, with a decent language-writing language to build on top of, the DSLs can compose with the base language and with each other – making it easy for users to combine an R-like statistical language with an airline management language, allowing complex statistical computation over aspects of flight segments or ticket prices.
